import { {{pascalCase moduleName}} } from "modules/{{moduleName}}/entity/{{moduleName}}.entity";
import { {{moduleName}}Repository } from "infra/repository";
import IContractUseCases from "infra/contracts";
import { ErrorHandler } from "infra/errorHandlers";

export default class {{pascalCase moduleName}}UseCases implements IContractUseCases<{{pascalCase moduleName}}> {
    constructor() {}

    async getAll(query = {}): Promise<{{pascalCase moduleName}}[]> {
        try {
            const response = await {{moduleName}}Repository.find();
            return response;
        } catch (error: unknown) {
            throw ErrorHandler.InternalServerError(error);
        }
    }

    async getOne(id: string): Promise<{{pascalCase moduleName}} | void> {
        try {
            const response = await {{moduleName}}Repository.findOneBy({ id });
            if (!response) {
                throw ErrorHandler.NotFound("{{pascalCase moduleName}} not found");
            }
            return response as {{pascalCase moduleName}};
        } catch (error: unknown) {
            throw ErrorHandler.InternalServerError(error);
        }
    }

    async create(data: Partial<{{pascalCase moduleName}}>): Promise<{{pascalCase moduleName}}> {
        try {
            const response = await {{moduleName}}Repository.save(data);
            return response;
        } catch (error: unknown) {
            throw ErrorHandler.InternalServerError(error);
        }
    }

    async update(id: string, data: Partial<{{pascalCase moduleName}}>): Promise<{{pascalCase moduleName}} | void> {
        try {
            const entity = await this.getOne(id);
            if (!entity) {
                throw ErrorHandler.NotFound("{{pascalCase moduleName}} not found");
            }
            await {{moduleName}}Repository.update(id, data);
            return { ...entity, ...data };
        } catch (error: unknown) {
            throw ErrorHandler.InternalServerError(error);
        }
    }

    async delete(id: string): Promise<void> {
        try {
            const entity = await this.getOne(id);
            if (!entity) {
                throw ErrorHandler.NotFound("{{pascalCase moduleName}} not found");
            }
            await {{moduleName}}Repository.delete(id);
        } catch (error: unknown) {
            throw ErrorHandler.InternalServerError(error);
        }
    }
}